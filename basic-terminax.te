//
// Basic Terminax Documentation
//
// Contact: blerg@terminalempire.com
//
// Terminax is the scripting language used by Terminal Empire
// https://www.terminalempire.com

/*
NOTES:
- Terminax code files end with .te, for example the startup script is located at \system\startup.te
- Parameters with * are optional, ie: forecolor, backcolor* when creating a new color style.
- Variable names and function names are not case sensitive, however consistency is encouraged.
- Assigning text doesn't require double quotes "text" in all cases, however it is generally encouraged.
- The x and y position locations that are given to objects is relative to its container window. (unless being drawn outside of a window)
- Terminax does NOT use semi-colons at the end of lines. This will destroy your code.
- Terminax does NOT support ; to have multiple code lines on the same line.
- Supported Date and Time Functions take any Microsoft .NET DateTime format string.

OBJECTS vs STYLES:
There is a distinction between the objects created by different functions.
OBJECT EXAMPLES: window, text, button, image, input
STYLE EXAMPLES: font, color, border
Both of these are created by functions, and returned into variables that link to the object or style.
Styles are typically assigned to objects using $someObject.someProperty = $someStyle
(Dev note - All OBJECTS use the EngineObject class. STYLES use their own distinct classes.
*/


// VARIABLES
// Declare only one variable per line.
// Examples:
$someVar = 10
$someVar2 = $otherVar + 1

// JOINING VARIABLES INTO STRINGS
$var1 = 10
$someString = "The number is $var1" // this is correct
// Periods are not required to join strings together, and should NOT be used.
// This is wrong:
$some = "This number is ".$var1 // periods are not necessary to join strings.


// WINDOW POSITIONS
// The center of the Terminax Screen starts at 0,0.
// Thus X and Y positions of windows can
// sometimes start at negative values if they are going to be centered.

// STYLE: FONTS
// Supported fonts names are provided in json.
// Parameters Option: name, size
$someFont = font("Play-Bold",14)

// STYLE: COLORS
// Color objects are created with a selection of some number of colors.
// Parameters Option: color1, color2, color3, color4 ... etc
// Color objects contain 1 or more color, each taking up a new parameter.
// Windows color names, hex color codes, and rgb values in double quotes are all valid:
$someColor1 = color(blue)
$someColor2 = color("blue")
$someColor3 = color(#000, #EEE)
$someColor3 = color("0,0,0", "255,255,255", "255,0,0")
// Typically, when assigned to objects:
// color1 becomes the forecolor
// color2 becomes the backcolor
// In some specific cases, other colors are also used:
// color3 may become a text selection color, for example.


// STYLE: BORDERS
// Border function supports adding multiple border layers,
// where the border layers are drawn outwards from the object that the border is assigned to.
// Parameters Option: color, thickness
// Parameters Option: color, thickness, color, thickness ... (repeat if required)
$someBorder1 = border(green, 2) // a border with 1 layer, green and 2px thick
$someBorder2 = border(green, 2, blue, 4) // a border with 2 layers, green 2px, and a second thicker blue layer around it.length
$someBorder3 = border($someColor1, 4, $someColor2, 4) // a border with 2 layers, green 2px, and a second thicker blue layer around it.length


// OBJECT: WINDOW
// Parameters Option: x, y, width, height
$myWindow = window(100, 100, 500, 400)
$myWindow.border = $someBorder1 // assign a border to the object


// OBJECT: TEXT
// Create a text area.
// Parameters Option: text, x, y, width, height
// Parameters Option: text, x, y, [keyword], [keyword]
$myText = text("Hello, stranger!", 100, 100, 500, 400)
$myText.color = $someColor1 // assign a color to the object, this can change both the text color (forecolor) and back color at the same time.



// NEGATIVE VALUES FOR OBJECT POSITIONS
// x = 10 will place the object 10 px away from the left side
// x = -10 will place the object 10 px away from the right side
// y = 10 will place the object 10 px away from the top side
// y = -10 will place the object 10 px away from the bottom side

// NEGATIVE VALUES FOR OBJECT SIZES
// width = 100 will set a width of 100 for the object
// width = -20 will set a width of the object to the maximum allowed (based on its window container), minus 20 from the right side.
// height = 80 will set a height of 80 for the object
// width = -40 will set a width of the object to the maximum allowed (based on its window container), minus 40 from the bottom side.




// OBJECT: BUTTON
// Parameters Option: title, x, y, width, height
$myButton = button("Click me asap!", 100, 100, 500, 400)
$myButton.border = $someBorder1 // assign a border to the object
$myButton.color = $someColor1 // assign a color to the object, this can change both the text color (forecolor) and back color at the same time.

// ADDITIONAL PROPERTY EXAMPLES
myButton.x = 100
myButton.y = 50
myButton.width = 200
myButton.height = 100

// THESE CAN ALSO BE ASSIGNED USING VARIABLES
$newXposition = 100
myButton.x = $newXposition

// STARTING OBJECTS AS INVIBLSE
// By adding a * at the end of an object creation line,
// you can start the object invisible, but still have it load in the background.
$myWindow = window(40,40,300,200)*
// Think of * as saying 'hold off on showing this for now'
// You can set the object to visible when ready, using either of:
$myWindow.show
$myWindow.visible = true
// This also works for other objects in the same way
$myButton = button("Click me asap!", 100, 100, 500, 400) // Start with VISIBLE object
$myButton = button("Click me asap!", 100, 100, 500, 400)* // Start with INVISIBLE object


// OBJECT: INPUT
// Input objects are single line text boxes that can be used to get user input.length
$myInput = input("Default Text", 100, 100, 400, 50)
// They can be assigned borders, fonts and color styles like all objects.length
$someColor = color(teal,red,green)
$myInput.color = $someColor

$someBorder = border(teal,4)
$myInput.border = $someBorder

$someFont = font("Verdana-Bold",10)
$myInput.font = $someFont

// Input objects also have some extra properties
// the .prefix lets you show a field name, as if asking for information.
$myInput.prefix = "Name"
// This will cause Name to be shown in the input box
// so the user knows what information the box is looking for.

// Input boxes also have an .indent property.
// this helps in the case where you have multiple input boxes,
// perhaps one under another, and you want the input typing area
// to start at the same x position for each one. (for neatness)
$myInput1.prefix = "Name"
$myInput1.indent = 100
$myInput2.prefix = "Age"
$myInput2,indent = 100
// If you were to not specify a matching indent amount,
// then the user typing x coordinate would be determined by
// the width of the prefix text alone.

// INPUT COLORS
// Color objects can take any number of colors, and each object type, for example INPUT,
// uses these colors in a specific way. In this case, 
// color 1 = text color of input object
// color 2 = background color of input object
// color 3 = text selection color of input object
// color 4 = prefix text color of input object
$textcol = white
$backcol = black
$selcol = green
$prefixcol = orange
$inpColor = color($textcol, $backcol, $selcol, $prefixcol)
$myInput = input("", 50,50,300,50)
// $inpColor will be immediately assigned to my input automatically.

// Borders can be created around input objects in the same way
// that they are added to text and button objects.

// INPUT UNDERLINED
// There are two properties which, when set, underline the users text
$myInput.dashcolor = green
$myInput.underlinecolor = green
// They can also be passed a color object
$someColor = color(green)
$myInput.dashcolor = green
// This gives another way to customize the input objects.





// CUSTOM FUNCTIONS
// Custom functions can be creted with the following structure:
function add {
  $sum = $1 + $2
  return $sum
}

// This is also valid, however the () are not required:
function add() {
  $sum = $1 + $2
  return $sum
}

// Custom functions do not require predefining the parameters that are passed to them.
// However, any number of parameters may be passed to a custom function.
// These parameters are easily accessible from within the function
// by referencing the variable names $1, $2 ... $n as needed.

// You can add short descriptions to custom functions
// with inline comments as follows:
function add{ // add two numbers
  $sum = $1 + $2
  return $sum
}
// Comments added to custom functions in this way will 
// automatically be seen as a 'short description' of your function, and treated as such.

// Using custom functions
$someVariable = add(5,10) // this will put 15 into $someVariable
$someObject.text = Solution is $someVariable
// or
// call a function directly into an object property.
$someObject.someProperty = some_function($someParam, $someParam2)


// FUNCTIONS CAN RETURN OBJECTS
// for example you can make a button creation function
// Just MAKE SURE to "return" the button you created to the variable
// that called the function.
function new_button{
  $text = $1
  $b = button($text,10,10,100,50)
  return $b // don't forget this
}
$myButton = new_button("click me asap")
// Using functions to create objects like this 
// can make it easier to customize your styles with less code.






// OBJECT EVENTS
// Custom functions can be made to trigger on certain player actions.
// Multiple custom functions can be set to the same trigger events.

// Events are assigned to objects using the > operator,
// which links them up to be activated later.

function randomize(){ // generate a random numer
    $randomnum = random(1,1000)
    // now we can do something with it
}


// Valid events for some objects (like windows, button and text objects)

// Right Mouse Button
// (.click and .mouseup are effectively the same)
$someObject.click > randomize()
$someObject.mousedown > randomize()
$someObject.mouseup > randomize()
$someObject.doubleclick > randomize()

// Similar events exist for the l
$someObject.mousedown_right > randomize()
$someObject.mouseup_right > randomize()
$someObject.doubleclick_right > randomize()

// These are both valid, assuming no parameters are required.
$someObject.click > randomize()
$someObject.click > randomize

//You can also pass variables or values:
function randomize_custom(){ // generate a random numer
    $min = $1
    $max = $2
    $randomnum = random($min,$max)
    // now we can do something with it
{

// These parameters are then collected from within the custom function
// by referencing $1 and $2
$someObject.click > randomize_custom(50,100)

// If required, all events can be remove from an object
$someObject.clearevents

// TIMERS
// Timers can also be used to call custom functions.length
$timer1 = timer(1000)
// The main parameter is the interval in ms. 1000 = 1 second
// There is a minimal interval that is under 100ms. (subject to change)
// Assign custom functions to a timer by using the tick property.
$timer1.tick > randomize_custom(50,100)
// This has identical syntax to assigning custom functions to object events,
// like .click and .mousedown.
// MULTIPLE EVENTS can be added to the same timer.
// All events on a timer will be run at the same interval.
// Just reuse the tick property to add more custom functions.
$timer1.tick > my_function_1()
$timer1.tick > my_function_2()
// you can clear them with
$timer1.clearevents
// Timers created at the same time with the same interval are in sync.
// If they need to be randomized against each other use .desync
// This may be useful if you want to randomize UI updates with multiple timers.
// and dont want everything changing in sync.
$timer1.desync


// FOR LOOPS
// Terminax supports FOR LOOPS in the following format:
FOR $n = 1 to 10
  // optionally, we can do something with $n in here
NEXT

// MORE EXAMPLES
$start = 10
$end = 20
$step = 2
FOR $n = $start to $end STEP $step
  // the step value will make it count by two, each iteration
  // 10, 12, 14, 16, 18, 20
NEXT

// BACKWARDS FOR LOOPS
FOR $n = $end to $start STEP -1
  // the step value will make it count by two, each iteration
  // 20, 19, 18 ... 10
NEXT


// NESTED LOOPS 
// Terminax supports nested loops
FOR $n1 = 0 to 255
  FOR $n2 = 0 to 255
    FOR $n3 = 0 to 255
      $ip_address = $n1.$n2.$n3 // loop through
   NEXT
  NEXT
NEXT

// WHILE LOOPS
// Terminax supports WHILE LOOPS in the following format:
WHILE $val1 < $val2
  // do things
LOOP

// Valid operators are <=, =<, >=, =>, <>, =, <, >
// Any of these can be used between $val1 and $val2
// WHILE LOOPS can also be nested.length

// IF STATEMENTS
// Terminax supports IF STATEMENTS in the following format;
IF $value > 10
  // something
END IF

// MORE EXAMPLES
IF $val = "john"
  // something
ELSE IF $val = "joan"
  // something
ELSE
  // something
ENDIF

// The AND keyword can check multiple things and once
IF $val1 = "something" and $val2 = "another thing"
// do things
END IF

// The OR keyword is also valid
IF $val1 = "something" and $val2 = "another thing"
// do things
END IF

// Note that Brackets () are *NOT* currently supported on IF condition lines.


// The "then" keyword is supported, but is not encouraged.
IF $val = 4 THEN
  // something
END IF

// Like FOR LOOPS and WHILE LOOPS, IF statements can also be nested.
IF $password = "secret123"
  IF $accesslevel > 4
    $window1.show
  ELSE
    $window2.show
  END IF
ELSE
  $someObject.text = "access denied!!!"
END IF

// IF STATEMENTS can check single values
// In this case, $someVal will be true UNLESS it is 0, the word "false", or an empty value.
$someVal = 1
IF $someVal
   // code
ELSE
  // code
END IF



// CALLING FUNCTIONS
// There are two ways to call a function.
// With a return value:
$var = function_name()
// Without a return value:
function_name()
// If calling a function without expecting a return value,
// you MUST use the () so Terminax knows to look for this function.


// Never forget to assign an event to your timer using
$someTimer.tick > custom_function()




// CENTER OBJECTS
// .center, .centerx, and .centery can be used to quickly center windows and objects.
$myWindow.center // center window in x and y
$myObject.center // center object in its parent window
$myObject.centerx // center objects x coordinate in its parent window
$myObject.centery // center objects y coordinate in its parent window


// COMMANDS
// You can use the following commands in scripts
exit // this immediately exits a script or a custom function.

